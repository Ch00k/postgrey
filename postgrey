#!/usr/sepp/bin/perl-5.8.4 -w

# postgrey: a postfix greylisting policy server
# Copyright 2004 (c) ETH Zurich
# released under the GNU General Public License

# see the documentation with 'perldoc postgrey'

use lib '/usr/pack/netserver-perl-0.87-ds/lib/perl';

package postgrey;
use strict;
use Pod::Usage;
use Getopt::Long 2.25 qw(:config posix_default no_ignore_case);
use Net::Server::Multiplex;
use BerkeleyDB;

use vars qw(@ISA);
@ISA = qw(Net::Server::Multiplex);

'$Revision: 4 $ ' =~ /Revision: (\S*)/;
my $Revision = $1;

# local policy about what users want greylisting:
sub policing_is_wanted($)
{
    my ($attr) = @_;

    my %greylist_domains = (
        'list.ee.ethz.ch' => 1,
    );

    my %greylist_users = (
        'dws@ee.ethz.ch' => 1,
        'oetiker@ee.ethz.ch' => 1,
        'zaucker@ee.ethz.ch' => 1,
        'fritz.zaucker@ee.ethz.ch' => 1,
        'moetiker@ee.ethz.ch' => 1,
        'thaler@ee.ethz.ch' => 1,
        'isg@ee.ethz.ch' => 1,
        'root@ee.ethz.ch' => 1,
        'unix-admin@ee.ethz.ch' => 1,
        'afg@ee.ethz.ch' => 1,
    );

    return 1 if $attr->{recipient}=~/@(\S+)$/ and $greylist_domains{$1};
    return 1 if $greylist_users{$attr->{recipient}};
    return 0;
}

#Copyright raeburn at raeburn.org
#Retrieved from: http://lists.puremagic.com/pipermail/greylist-users/2003-October/000276.html
sub do_verp_substitutions($)
{
    my ($x) = @_;
    my ($localpart, $hostpart) = split("@", $x, 2);

    if (!defined $hostpart) {
        return $x;
    }
    # The most popular form seems to be
    # "listid-msgnumber-encodedrecipient at listhost".  The message
    # number has dashes before and after it.
    $localpart =~ s/-[0-9][0-9]*-/-#-/g;

    # Do it again in case there are three such blocks strung together,
    # as in Yahoo Groups sender ids.
    $localpart =~ s/-[0-9][0-9]*-/-#-/g;

    # The mailer used at lists.math.uh.edu for the Gnus developers'
    # list uses these forms.  Not sure what list package they're using.
    $localpart =~ s/\+M[0-9][0-9]*$/+M#/;
    $localpart =~ s/\+M[0-9][0-9]*=/+M#=/;

    return "$localpart\@$hostpart";
}

sub do_maintenance($$)
{
    my ($self, $now) = @_;
    my $db  = $self->{postgrey}{db};

    for my $key (keys %$db) {
        my $last = (split(/,/,$db->{$key}))[1];
        if($now - $last > $self->{postgrey}{max_age}) {
            delete $db->{$key};
        }
    }
}

# main routine: based on attributes specified as argument, return policy decision
sub smtpd_access_policy($$)
{
    my ($self, $attr) = @_;
    my $db  = $self->{postgrey}{db};
    my $now = time();

    # lookup
    my $sender = do_verp_substitutions($attr->{sender});
    my $key    = lc "$attr->{client_address}/$sender/$attr->{recipient}";
    my $val    = $db->{$key};
    my $first  = defined $val ? (split(/,/,$val))[0] : $now;

    # update
    $db->{$key}="$first,$now";

    # do maintenance if one hour has passed since the last one
    if($now-$self->{postgrey}{last_maint} > 3600) {
        $self->{postgrey}{last_maint} = $now;
        $self->do_maintenance($now);
    }

    # restrict policing to users that want it
    policing_is_wanted($attr) or return 'dunno';

    # decide
    $self->log(4, "request age ".($now - $first));
    if ($now - $first < $self->{postgrey}{delay}) {
        return "defer_if_permit Greylisted for $self->{postgrey}{delay} seconds...";
    }

    return 'dunno';
}

sub main()
{
    # save arguments for Net:Server HUP restart
    my @ARGV_saved = @ARGV;

    # parse options
    my %opt = ();
    GetOptions(\%opt, 'help|h', 'man', 'version', 'noaction|no-action|n',
        'verbose|v', 'daemonize|d', 'unix|u=s', 'inet|i=s', 'user=s', 'dbdir=s',
        'delay=i', 'max-age=i') or exit(1);
    if($opt{help})     { pod2usage(1) }
    if($opt{man})      { pod2usage(-exitstatus => 0, -verbose => 2) }
    if($opt{version})  { print "template_tool $Revision\n"; exit(0) }
    if($opt{noaction}) { die "ERROR: don't know how to \"no-action\".\n" }

    defined $opt{unix} or defined $opt{inet} or
        die "ERROR: --unix or --inet must be specified\n";

    # bind only localhost if no host is specified
    if(defined $opt{inet} and $opt{inet}=~/^\d+$/) {
        $opt{inet} = "localhost:$opt{inet}";
    }

    # create Net::Server object and run it
    my $server = bless {
        server => {
            commandline    => [ $0, @ARGV_saved ],
            delay          => $opt{delay} || 600,
            port           => [ $opt{inet} ? $opt{inet} : $opt{unix} ],
            proto          => $opt{inet} ? 'tcp' : 'unix',
            user           => $opt{user} || 'postgrey',
            dbdir          => $opt{dbdir} || '/var/spool/postfix/postgrey',
            setsid         => $opt{daemonize} ? 1 : undef,
            log_level      => $opt{verbose} ? 1 : 3,
            log_facilty    => 'mail',
            log_file       => $opt{daemonize} ? 'Sys::Syslog' : undef,
            syslog_logsock => 'inet',
        },
        postgrey => {
            delay          => $opt{delay}        || 600,
            dbdir          => $opt{dbdir}        || '/var/spool/postfix/postgrey',
            max_age        => $opt{'max-age'}    || 14,
            last_maint     => time(),
        },
    }, 'postgrey';

    # max_age is in days
    $server->{postgrey}{max_age}*=3600*24;

    $server->run;
}

##### Net::Server::Multiplex methods:

sub pre_loop_hook()
{
    my ($self) = @_;

    # open database with transactions, locking and auto-commit to make it as
    # safe as possible.
    my $env = BerkeleyDB::Env->new(
        -Home     => $self->{server}{dbdir},
        -Flags    => DB_CREATE|DB_INIT_TXN|DB_INIT_MPOOL|DB_INIT_LOG|DB_INIT_LOCK,
        -SetFlags => DB_AUTO_COMMIT,
    ) or die "ERROR: can't create DB environment: $!\n";

    tie(%{$self->{postgrey}{db}}, 'BerkeleyDB::Btree',
        -Filename => 'postgrey.db',
        -Flags    =>  DB_CREATE,
        -Env      => $env
    ) or die "ERROR: can't create database $self->{server}{dbdir}/postgrey.db: $!\n";
}

sub mux_input()
{
    my ($self, $mux, $fh, $in_ref) = @_;
    defined $self->{postgrey_attr} or $self->{postgrey_attr} = {};
    my $attr = $self->{postgrey_attr};

    # consume entire lines
    while ($$in_ref =~ s/^([^\n]*)\n//) {
        next unless defined $1;
        my $in = $1;
        if($in =~ /([^=]+)=(.*)/) {
            # read attributes
            $attr->{substr($1, 0, 512)} = substr($2, 0, 512);
        }
        elsif($in eq '') {
            defined $attr->{request} or $attr->{request}='';
            if($attr->{request} ne 'smtpd_access_policy') {
                $self->{net_server}->log(1, "unrecognized request type: '$attr->{request}'");
            }
            else {
                # decide
                my $action = $self->{net_server}->smtpd_access_policy($attr);
                # debug
                if($self->{net_server}{server}{log_level}>3) {
                    my $a = 'request: ';
                    $a .= join(' ', map {"$_=$attr->{$_}"} (sort keys %$attr));
                    $a .= " action=$action";
                    $self->{net_server}->log(2, $a);
                }
                # give answer
                print $fh "action=$action\n\n";
            }
            $self->{postgrey_attr} = {};
        }
        else {
             $self->{net_server}->log(1, "ignoring garbage: <".substr($in, 0, 100).">");
        }
    }
}

main;

__END__

=head1 NAME

postgrey - Postfix Greylist Policy Server

=head1 SYNOPSIS

B<postgrey> [I<options>...]

 -h, --help               display this help and exit
     --version            output version information and exit
 -v, --verbose            increase verbosity level

 -u, --unix=PATH          listen on unix socket PATH
 -i, --inet=[HOST:]PORT   listen on PORT, localhost if HOST is not specified
 -d, --daemonize          run in the background
     --user=USER          run as USER (default: postgrey)
     --dbdir=PATH         put db files in PATH (default: /var/spool/postfix/postgrey)
     --delay=N            greylist for N seconds (default: 600)
     --max-age=N          delete entries older than N days since the last time that
                          they have been seen

=head1 DESCRIPTION

Postgry is a Postfix policy server implementing greylisting.

=head1 COPYRIGHT

Copyright (c) 2004 by ETH Zurich. All rights reserved.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

=head1 AUTHOR

S<David Schweikert E<lt>dws@ee.ethz.chE<gt>>

=head1 HISTORY

 2004-05-20 ds Initial Version

=cut

# Emacs Configuration
#
# Local Variables:
# mode: cperl
# eval: (cperl-set-style "PerlStyle")
# mode: flyspell
# mode: flyspell-prog
# End:
#
# vi: sw=4 et
