#!/usr/sepp/bin/perl-5.8.4 -w

# postgrey: a postfix greylisting policy server
# Copyright 2004 (c) ETH Zurich
# released under the GNU General Public License

# see the documentation with 'perldoc postgrey'

use lib '/usr/pack/netserver-perl-0.87-ds/lib/perl';
package postgrey;
use strict;
use Pod::Usage;
use Getopt::Long 2.25 qw(:config posix_default no_ignore_case);
use Net::Server::Multiplex;
use BerkeleyDB;
use Fcntl ':flock'; # import LOCK_* constants

use vars qw(@ISA);
@ISA = qw(Net::Server::Multiplex);

my $VERSION = "1.9rc1";

sub read_whitelists($)
{
    my ($self) = @_;

    # clients
    my @whitelist_clients;
    if(open(CLIENTS, $self->{postgrey}{whitelist_clients_file})) {
        while(<CLIENTS>) {
            s/^\s+//; s/\s+$//;
            next if $_ eq '';
            next if /^#/;
            if(/^\S+$/) {
                push @whitelist_clients, qr{\Q$_\E$}i;
            }
            else {
                warn "WARNING: $self->{postgrey}{whitelist_clients_file} line $.: doesn't look like a hostname\n";
            }
        }
    }
    else {
        warn "WARNING: can't open whitelist-clients: $self->{postgrey}{whitelist_clients_file}\n";
    }
    close(CLIENTS);
    $self->{postgrey}{whitelist_clients} = \@whitelist_clients;

    # recipients
    my @whitelist_recipients;
    if(open(RECIPIENTS, $self->{postgrey}{whitelist_recipients_file})) {
        while(<RECIPIENTS>) {
            s/^\s+//; s/\s+$//;
            next if $_ eq '';
            next if /^#/;
            my ($user, $domain) = split(/\@/, $_, 2);
            if(!/^\S+$/) {
                warn "WARNING: $self->{postgrey}{whitelist_recipients_file} line $.: doesn't look like an address\n";
            }
            # postfix access(5) syntax:
            elsif(defined $domain and $domain ne '') {
                # user@domain (match also user+extension@domain)
                push @whitelist_recipients, qr{^\Q$user\E(?:\+[^@]+)?\@\Q$domain\E$}i;
            }
            elsif(defined $domain) {
                # user@
                push @whitelist_recipients, qr{^\Q$user\E(?:\+[^@]+)?\@}i;
            }
            else {
                # domain ($user is the domain)
                push @whitelist_recipients, qr{\Q$user\E$}i;
            }
        }
    }
    else {
        warn "WARNING: can't open whitelist-recipients: $self->{postgrey}{whitelist_recipients_file}\n";
    }
    close(RECIPIENTS);
    $self->{postgrey}{whitelist_recipients} = \@whitelist_recipients;
}

sub do_sender_substitutions($$)
{
    my ($self, $addr) = @_;

    # replace numbers in VERP addresses with '#' so that
    # we don't create a new key for each mail
    my ($user, $domain) = split(/@/, $addr, 2);
    defined $domain or return $addr;
    # replace numbers with #
    $user =~ s/\b\d+\b/#/g;
    return "$user\@$domain";
}

sub do_client_substitutions($$$)
{
    my ($self, $ip, $revdns) = @_;

    # --lookup-by-subnet:
    if($self->{postgrey}{lookup_by_subnet}) {
        return $ip if $revdns eq 'unknown';
        my @ip=split(/\./, $ip);
        return $ip unless defined $ip[3];
        # skip if it contains the last two IP numbers in the hostname
        # (we assume it is a pool of dialup addresses of a provider)
        return $ip  if $revdns =~ /\b$ip[2]\b/ and $revdns =~ /\b$ip[3]\b/;
        return join('.', $ip[0..2], '0');
    }
    return $ip;
}

sub do_maintenance($$)
{
    my ($self, $now) = @_;
    my $db     = $self->{postgrey}{db};
    my $db_env = $self->{postgrey}{db_env};

    # remove old db logs

    $self->log(2, "cleaning up old logs...");
    $db_env->txn_checkpoint(0, 0) and
        warn "can't checkpoint !? $BerkeleyDB::Error";
    for my $l ($db_env->log_archive(DB_ARCH_ABS)) {
        $self->log(2, "rm $l");
        unlink $l or warn "can't remove db log $l: $!\n";
    }

    # remove old keys
    # this is very expensive:  We might refuse to speak to postfix for too
    # long, after which clients will start getting "450 Server configuration
    # problem" errors... do it only during the night and only if at least one
    # day has passed
    my $hour = (localtime($now))[2];
    if($hour > 1 and $hour < 7 and
        $now - $self->{postgrey}{last_maint_keys} >= 82800)
    {
        $self->log(2, "cleaning up old entries...");
        my $max_age = $self->{postgrey}{max_age};
        my ($nr_keys_before, $nr_keys_after) = (0,0);
        while (my ($key, $value) = each %$db) {
            $nr_keys_before++;
            my $last = (split(/,/,$value))[1];
            if($now - $last > $max_age) {
                delete $db->{$key};
            }
            else {
                $nr_keys_after++;
            }
        }
        $self->{postgrey}{last_maint_keys}=$now;
        $self->log(2, "cleaning finished. before: $nr_keys_before, after: $nr_keys_after");
    }
}

# main routine: based on attributes specified as argument, return policy decision
sub smtpd_access_policy($$)
{
    my ($self, $attr) = @_;
    my $db  = $self->{postgrey}{db};
    my $now = time();

    # whitelists
    for my $w (@{$self->{postgrey}{whitelist_clients}}) {
        return 'dunno' if $attr->{client_name} =~ $w;
    }
    for my $w (@{$self->{postgrey}{whitelist_recipients}}) {
        return 'dunno' if $attr->{recipient} =~ $w;
    }

    # lookup
    my $sender = $self->do_sender_substitutions($attr->{sender});
    my $client = $self->do_client_substitutions(
        $attr->{client_address}, $attr->{client_name}
    );
    my $key    = lc "$client/$sender/$attr->{recipient}";
    my $val    = $db->{$key};
    my $first  = defined $val ? (split(/,/,$val))[0] : $now;

    # update
    $db->{$key}="$first,$now";

    # do maintenance if one hour has passed since the last one
    if($now-$self->{postgrey}{last_maint} >= 3600) {
        $self->{postgrey}{last_maint} = $now;
        $self->do_maintenance($now);
    }

    # decide
    $self->log(4, "request age ".($now - $first));
    my $diff = $self->{postgrey}{delay} - ($now - $first);
    if ($diff > 0 ) {
        return "defer_if_permit Greylisted for $diff seconds...";
    }

    return 'dunno';
}

sub main()
{
    # save arguments for Net:Server HUP restart
    my @ARGV_saved = @ARGV;

    # parse options
    my %opt = ();
    GetOptions(\%opt, 'help|h', 'man', 'version', 'noaction|no-action|n',
        'verbose|v', 'daemonize|d', 'unix|u=s', 'inet|i=s', 'user=s',
        'dbdir=s', 'pidfile=s', 'delay=i', 'max-age=i',
        'lookup-by-subnet', 'whitelist-clients=s', 'whitelist-recipients=s'
        ) or exit(1);
    if($opt{help})     { pod2usage(1) }
    if($opt{man})      { pod2usage(-exitstatus => 0, -verbose => 2) }
    if($opt{version})  { print "postgrey $VERSION\n"; exit(0) }
    if($opt{noaction}) { die "ERROR: don't know how to \"no-action\".\n" }

    defined $opt{unix} or defined $opt{inet} or
        die "ERROR: --unix or --inet must be specified\n";

    # bind only localhost if no host is specified
    if(defined $opt{inet} and $opt{inet}=~/^\d+$/) {
        $opt{inet} = "localhost:$opt{inet}";
    }

    # create Net::Server object and run it
    my $server = bless {
        server => {
            commandline      => [ $0, @ARGV_saved ],
            port             => [ $opt{inet} ? $opt{inet} : $opt{unix}."|unix" ],
            proto            => $opt{inet} ? 'tcp' : 'unix',
            user             => $opt{user} || 'postgrey',
            dbdir            => $opt{dbdir} || '/var/spool/postfix/postgrey',
            setsid           => $opt{daemonize} ? 1 : undef,
            pid_file         => $opt{daemonize} ? $opt{pidfile} : undef,
            log_level        => $opt{verbose} ? 4 : 2,
            log_file         => $opt{daemonize} ? 'Sys::Syslog' : undef,
            syslog_logsock   => $^O eq 'solaris' ? 'inet' : 'unix',
            syslog_facility  => 'mail',
            syslog_ident     => 'postgrey',
        },
        postgrey => {
            delay            => $opt{delay}     || 300,
            dbdir            => $opt{dbdir}     || '/var/spool/postfix/postgrey',
            max_age          => $opt{'max-age'} || 14,
            last_maint       => time,
            last_maint_keys  => 0, # do it on the first night
            lookup_by_subnet => $opt{'lookup-by-subnet'},
            whitelist_clients_file    => $opt{'whitelist-clients'} ||
                '/etc/postfix/postgrey_whitelist_clients',
            whitelist_recipients_file => $opt{'whitelist-recipients'} ||
                '/etc/postfix/postgrey_whitelist_recipients',
        },
    }, 'postgrey';

    # max_age is in days
    $server->{postgrey}{max_age}*=3600*24;

    # read whitelist
    $server->read_whitelists();

    $server->run;
}

##### Net::Server::Multiplex methods:

sub pre_loop_hook()
{
    my ($self) = @_;

    # write files with mode 600
    umask 0077;

    # unix socket permissions should be 666
    if($self->{server}{proto} eq 'unix') {
        my $unix_path = $self->{server}{port}[0];
        $unix_path =~ s/\|unix$//;
        chmod 0666, $unix_path;
    }

    # ensure that only one instance of postgrey is running
    my $lock = "$self->{server}{dbdir}/postgrey.lock";
    open(LOCK, ">>$lock") or die "ERROR: can't open lock file: $lock\n";
    flock(LOCK, LOCK_EX|LOCK_NB) or die "ERROR: locked: $lock\n";

    # be sure to put in syslog any warnings / fatal errors
    if($self->{server}{log_file} eq 'Sys::Syslog') {
        $SIG{__WARN__} = sub { Sys::Syslog::syslog('warning', "warning: $_[0]") };
        $SIG{__DIE__}  = sub { Sys::Syslog::syslog('crit', "fatal: $_[0]"); die @_; };
    }

    # open database with transactions, logging and auto-commit to make it as
    # safe as possible. Note that locking is not required since only one
    # process is running
    $self->{postgrey}{db_env} = BerkeleyDB::Env->new(
        -Home     => $self->{server}{dbdir},
        -Flags    => DB_CREATE|DB_RECOVER|DB_INIT_TXN|DB_INIT_MPOOL|DB_INIT_LOG,
        -SetFlags => DB_AUTO_COMMIT|DB_TXN_NOSYNC,
    ) or die "ERROR: can't create DB environment: $!\n";

    tie(%{$self->{postgrey}{db}}, 'BerkeleyDB::Btree',
        -Filename => 'postgrey.db',
        -Flags    => DB_CREATE,
        -Env      => $self->{postgrey}{db_env}
    ) or die "ERROR: can't create database $self->{server}{dbdir}/postgrey.db: $!\n";
}

sub mux_input()
{
    my ($self, $mux, $fh, $in_ref) = @_;
    defined $self->{postgrey_attr} or $self->{postgrey_attr} = {};
    my $attr = $self->{postgrey_attr};

    # consume entire lines
    while ($$in_ref =~ s/^([^\r\n]*)\r?\n//) {
        next unless defined $1;
        my $in = $1;
        if($in =~ /([^=]+)=(.*)/) {
            # read attributes
            $attr->{substr($1, 0, 512)} = substr($2, 0, 512);
        }
        elsif($in eq '') {
            defined $attr->{request} or $attr->{request}='';
            if($attr->{request} ne 'smtpd_access_policy') {
                $self->{net_server}->log(2, "unrecognized request type: '$attr->{request}'");
            }
            else {
                # decide
                my $action = $self->{net_server}->smtpd_access_policy($attr);
                # debug
                if($self->{net_server}{server}{log_level}>=4) {
                    my $a = 'request: ';
                    $a .= join(' ', map {"$_=$attr->{$_}"} (sort keys %$attr));
                    $a .= " action=$action";
                    $self->{net_server}->log(4, $a);
                }
                # give answer
                print $fh "action=$action\n\n";
            }
            $self->{postgrey_attr} = {};
        }
        else {
             $self->{net_server}->log(2, "ignoring garbage: <".substr($in, 0, 100).">");
        }
    }
}

main;

__END__

=head1 NAME

postgrey - Postfix Greylisting Policy Server

=head1 SYNOPSIS

B<postgrey> [I<options>...]

 -h, --help             display this help and exit
     --version          output version information and exit
 -v, --verbose          increase verbosity level

 -u, --unix=PATH        listen on unix socket PATH
 -i, --inet=[HOST:]PORT listen on PORT, localhost if HOST is not specified
 -d, --daemonize        run in the background
     --pidfile=PATH     put daemon pid into this file
     --user=USER        run as USER (default: postgrey)
     --dbdir=PATH       put db files in PATH (default: /var/spool/postfix/postgrey)
     --delay=N          greylist for N seconds (default: 300)
     --max-age=N        delete entries older than N days since the last time
                        that they have been seen (default: 14)
     --lookup-by-subnet strip the last 8 bits from IP addresses
     --whitelist-clients=FILE     default: /etc/postfix/postgrey_whitelist_clients
     --whitelist-recipients=FILE  default: /etc/postfix/postgrey_whitelist_recipients

=head1 DESCRIPTION

Postgrey is a Postfix policy server implementing greylisting.

When a request for delivery of a mail is received by Postfix via SMTP, the
triplet C<CLIENT_IP> / C<SENDER> / C<RECIPIENT> is built. If it is the first
time that this triplet is seen, or if the triplet was first seen less than
I<delay> seconds (300 is the default), then the mail gets rejected with a
temporary error. Hopefully spammers or viruses will not try again later, as it
is however required per RFC.

=head2 Installation

=over 4

=item *

Create a C<postgrey> user and the directory where to put the database I<dbdir>
(default: C</var/spool/postfix/postgrey>)

=item *

Write an init script to start postgrey at boot and start it. Like this for example:

 postgrey --inet=10023 -d

=item *

Put something like this in /etc/main.cf:

 smtpd_recipient_restrictions =
               ...
               reject_unauth_destination
               check_policy_service inet:127.0.0.1:10023

=item *

Install the provided postgrey_whitelist_clients and
postgrey_whitelist_recipients in /etc/postfix.

=item *

Put in /etc/postfix/postgrey_whitelist_recipients users that do not want
greylisting.

=back

=head2 SEE ALSO

See L<http://www.greylisting.org/> for a description of what greylisting is
and L<http://www.postfix.org/SMTPD_POLICY_README.html> for a description of how
Postfix policy servers work.

=head1 COPYRIGHT

Copyright (c) 2004 by ETH Zurich. All rights reserved.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

=head1 AUTHOR

S<David Schweikert E<lt>dws@ee.ethz.chE<gt>>

=head1 HISTORY

 2004-05-20 ds Initial Version

=cut

# Emacs Configuration
#
# Local Variables:
# mode: cperl
# eval: (cperl-set-style "PerlStyle")
# mode: flyspell
# mode: flyspell-prog
# End:
#
# vi: sw=4 et
