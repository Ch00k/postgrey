#!/usr/sepp/bin/perl-5.8.4 -w

# postgrey: a postfix greylisting policy server
# Copyright 2004 (c) ETH Zurich
# released under the GNU General Public License

# see the documentation with 'perldoc postgrey'

use lib '/usr/pack/netserver-perl-0.87-ds/lib/perl';
package postgrey;
use strict;
use Pod::Usage;
use Getopt::Long 2.25 qw(:config posix_default no_ignore_case);
use Net::Server::Multiplex;
use BerkeleyDB;
use Fcntl ':flock'; # import LOCK_* constants

use vars qw(@ISA);
@ISA = qw(Net::Server::Multiplex);

my $VERSION = '1.0';

#Copied from http://lists.puremagic.com/pipermail/greylist-users/2003-October/000276.html
#Author: raeburn at raeburn.org
sub do_verp_substitutions($)
{
    my ($x) = @_;
    my ($localpart, $hostpart) = split("@", $x, 2);

    if (!defined $hostpart) {
        return $x;
    }
    # The most popular form seems to be
    # "listid-msgnumber-encodedrecipient at listhost".  The message
    # number has dashes before and after it.
    $localpart =~ s/-[0-9][0-9]*-/-#-/g;

    # Do it again in case there are three such blocks strung together,
    # as in Yahoo Groups sender ids.
    $localpart =~ s/-[0-9][0-9]*-/-#-/g;

    # The mailer used at lists.math.uh.edu for the Gnus developers'
    # list uses these forms.  Not sure what list package they're using.
    $localpart =~ s/\+M[0-9][0-9]*$/+M#/;
    $localpart =~ s/\+M[0-9][0-9]*=/+M#=/;

    return "$localpart\@$hostpart";
}

sub do_maintenance($$)
{
    my ($self, $now) = @_;
    my $db     = $self->{postgrey}{db};
    my $db_env = $self->{postgrey}{db_env};

    # remove old db logs

    $self->log(2, "cleaning up old logs...");
    $db_env->txn_checkpoint(0, 0) and
        warn "can't checkpoint !? $BerkeleyDB::Error";
    for my $l ($db_env->log_archive(DB_ARCH_ABS)) {
        $self->log(2, "rm $l");
        unlink $l or warn "can't remove db log $l: $!\n";
    }

    # remove old keys
    # this is very expensive:  We might refuse to speak to postfix for too
    # long, after which clients will start getting "450 Server configuration
    # problem" errors... do it only during the night and only if at least one
    # day has passed
    my $hour = (localtime($now))[2];
    if($hour > 1 and $hour < 7 and
        $now - $self->{postgrey}{last_maint_keys} >= 82800)
    {
        $self->log(2, "cleaning up old entries...");
        my $max_age = $self->{postgrey}{max_age};
        while (my ($key, $value) = each %$db) {
            my $last = (split(/,/,$value))[1];
            delete $db->{$key} if $now - $last > $max_age;
        }
        $self->{postgrey}{last_maint_keys}=$now;
    }

    $self->log(2, "cleaning finished");
}

# main routine: based on attributes specified as argument, return policy decision
sub smtpd_access_policy($$)
{
    my ($self, $attr) = @_;
    my $db  = $self->{postgrey}{db};
    my $now = time();

    # lookup
    my $sender = do_verp_substitutions($attr->{sender});
    my $key    = lc "$attr->{client_address}/$sender/$attr->{recipient}";
    my $val    = $db->{$key};
    my $first  = defined $val ? (split(/,/,$val))[0] : $now;

    # update
    $db->{$key}="$first,$now";

    # do maintenance if one hour has passed since the last one
    if($now-$self->{postgrey}{last_maint} >= 3600) {
        $self->{postgrey}{last_maint} = $now;
        $self->do_maintenance($now);
    }

    # decide
    $self->log(4, "request age ".($now - $first));
    my $diff = $self->{postgrey}{delay} - ($now - $first);
    if ($diff > 0 ) {
        return "defer_if_permit Greylisted for $diff seconds...";
    }

    return 'dunno';
}

sub main()
{
    # save arguments for Net:Server HUP restart
    my @ARGV_saved = @ARGV;

    # parse options
    my %opt = ();
    GetOptions(\%opt, 'help|h', 'man', 'version', 'noaction|no-action|n',
        'verbose|v', 'daemonize|d', 'unix|u=s', 'inet|i=s', 'user=s', 'dbdir=s', 'pidfile=s',
        'delay=i', 'max-age=i') or exit(1);
    if($opt{help})     { pod2usage(1) }
    if($opt{man})      { pod2usage(-exitstatus => 0, -verbose => 2) }
    if($opt{version})  { print "postgrey $VERSION\n"; exit(0) }
    if($opt{noaction}) { die "ERROR: don't know how to \"no-action\".\n" }

    defined $opt{unix} or defined $opt{inet} or
        die "ERROR: --unix or --inet must be specified\n";

    # bind only localhost if no host is specified
    if(defined $opt{inet} and $opt{inet}=~/^\d+$/) {
        $opt{inet} = "localhost:$opt{inet}";
    }

    # create Net::Server object and run it
    my $server = bless {
        server => {
            commandline     => [ $0, @ARGV_saved ],
            port            => [ $opt{inet} ? $opt{inet} : $opt{unix}."|unix" ],
            proto           => $opt{inet} ? 'tcp' : 'unix',
            user            => $opt{user} || 'postgrey',
            dbdir           => $opt{dbdir} || '/var/spool/postfix/postgrey',
            setsid          => $opt{daemonize} ? 1 : undef,
            pid_file        => $opt{daemonize} ? $opt{pidfile} : undef,
            log_level       => $opt{verbose} ? 4 : 2,
            log_file        => $opt{daemonize} ? 'Sys::Syslog' : undef,
            syslog_facility => 'mail',
            syslog_logsock  => 'inet',
            syslog_ident    => 'postgrey',
        },
        postgrey => {
            delay           => $opt{delay}     || 300,
            dbdir           => $opt{dbdir}     || '/var/spool/postfix/postgrey',
            max_age         => $opt{'max-age'} || 14,
            last_maint      => time(),
            last_maint_keys => time(),
        },
    }, 'postgrey';

    # max_age is in days
    $server->{postgrey}{max_age}*=3600*24;

    $server->run;
}

##### Net::Server::Multiplex methods:

sub pre_loop_hook()
{
    my ($self) = @_;

    # write files with mode 600
    umask 0077;

    # ensure that only one instance of postgrey is running
    my $lock = "$self->{server}{dbdir}/postgrey.lock";
    open(LOCK, ">>$lock") or die "ERROR: can't open lock file: $lock\n";
    flock(LOCK, LOCK_EX|LOCK_NB) or die "ERROR: locked: $lock\n";

    # be sure to put in syslog any warnings / fatal errors
    if($self->{server}{log_file} eq 'Sys::Syslog') {
        $SIG{__WARN__} = sub { Sys::Syslog::syslog('warn', "warning: $_[0]") };
        $SIG{__DIE__}  = sub { Sys::Syslog::syslog('crit', "fatal: $_[0]"); die @_; };
    }

    # open database with transactions, logging and auto-commit to make it as
    # safe as possible. Note that locking is not required since only one
    # process is running
    $self->{postgrey}{db_env} = BerkeleyDB::Env->new(
        -Home     => $self->{server}{dbdir},
        -Flags    => DB_CREATE|DB_RECOVER|DB_INIT_TXN|DB_INIT_MPOOL|DB_INIT_LOG,
        -SetFlags => DB_AUTO_COMMIT|DB_TXN_NOSYNC,
    ) or die "ERROR: can't create DB environment: $!\n";

    tie(%{$self->{postgrey}{db}}, 'BerkeleyDB::Btree',
        -Filename => 'postgrey.db',
        -Flags    => DB_CREATE,
        -Env      => $self->{postgrey}{db_env}
    ) or die "ERROR: can't create database $self->{server}{dbdir}/postgrey.db: $!\n";
}

sub mux_input()
{
    my ($self, $mux, $fh, $in_ref) = @_;
    defined $self->{postgrey_attr} or $self->{postgrey_attr} = {};
    my $attr = $self->{postgrey_attr};

    # consume entire lines
    while ($$in_ref =~ s/^([^\n]*)\n//) {
        next unless defined $1;
        my $in = $1;
        if($in =~ /([^=]+)=(.*)/) {
            # read attributes
            $attr->{substr($1, 0, 512)} = substr($2, 0, 512);
        }
        elsif($in eq '') {
            defined $attr->{request} or $attr->{request}='';
            if($attr->{request} ne 'smtpd_access_policy') {
                $self->{net_server}->log(2, "unrecognized request type: '$attr->{request}'");
            }
            else {
                # decide
                my $action = $self->{net_server}->smtpd_access_policy($attr);
                # debug
                if($self->{net_server}{server}{log_level}>=4) {
                    my $a = 'request: ';
                    $a .= join(' ', map {"$_=$attr->{$_}"} (sort keys %$attr));
                    $a .= " action=$action";
                    $self->{net_server}->log(4, $a);
                }
                # give answer
                print $fh "action=$action\n\n";
            }
            $self->{postgrey_attr} = {};
        }
        else {
             $self->{net_server}->log(2, "ignoring garbage: <".substr($in, 0, 100).">");
        }
    }
}

main;

__END__

=head1 NAME

postgrey - Postfix Greylist Policy Server

=head1 SYNOPSIS

B<postgrey> [I<options>...]

 -h, --help             display this help and exit
     --version          output version information and exit
 -v, --verbose          increase verbosity level

 -u, --unix=PATH        listen on unix socket PATH
 -i, --inet=[HOST:]PORT listen on PORT, localhost if HOST is not specified
 -d, --daemonize        run in the background
     --pidfile=PATH     put daemon pid into this file
     --user=USER        run as USER (default: postgrey)
     --dbdir=PATH       put db files in PATH (default: /var/spool/postfix/postgrey)
     --delay=N          greylist for N seconds (default: 300)
     --max-age=N        delete entries older than N days since the last time
                        that they have been seen (default: 14)

=head1 DESCRIPTION

Postgrey is a Postfix policy server implementing greylisting.

When a request for delivery of a mail is received by Postfix via SMTP, the
triplet C<CLIENT_IP> / C<SENDER> / C<RECIPIENT> is built. If it is the first
time that this triplet is seen, or if the triplet was first seen less than
I<delay> seconds (300 is the default), then the mail gets rejected with a
temporary error. Hopefully spammers or viruses will not try again later, as it
is however required per RFC.

=head2 Installation

=over 4

=item *

Create a C<postgrey> user and the directory where to put the database I<dbdir>
(default: C</var/spool/postfix/postgrey>)

=item *

Write an init script to start postgrey at boot and start it. Like this for example:

 postgrey --inet=10023 -d

=item *

Put something like this in /etc/main.cf:

 smtpd_recipient_restrictions =
               ...
               reject_unauth_destination
               check_client_access    hash:/etc/postfix/postgrey_client_access
               check_recipient_access hash:/etc/postfix/postgrey_recipient_access
               check_policy_service inet:127.0.0.1:10023

=item *

Install the provided postgrey_client_access in /etc/postfix and postmap it.
Some servers do not behave correctly and do not resend mails (as required in
the standard) or use complicated unique return addresses.

=item *

Put in /etc/postfix/postgrey_recipient_access users that do not want greylisting
like this:

  i_like_spam@ee.ethz.ch                OK

=back

=head2 SEE ALSO

See L<http://www.greylisting.org/> for a description of what greylisting is
and L<http://www.postfix.org/SMTPD_POLICY_README.html> for a description of how
Postfix policy servers work.

=head1 COPYRIGHT

Copyright (c) 2004 by ETH Zurich. All rights reserved.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

=head1 AUTHOR

S<David Schweikert E<lt>dws@ee.ethz.chE<gt>>

=head1 HISTORY

 2004-05-20 ds Initial Version

=cut

# Emacs Configuration
#
# Local Variables:
# mode: cperl
# eval: (cperl-set-style "PerlStyle")
# mode: flyspell
# mode: flyspell-prog
# End:
#
# vi: sw=4 et
