#!/usr/sepp/bin/perl-5.8.4 -w

# postgrey: a postfix greylisting policy server
# Copyright 2004 (c) ETH Zurich
# released under the GNU General Public License

# see the documentation with 'perldoc postgrey'

use lib '/usr/pack/netserver-perl-0.87-ds/lib/perl';
package postgrey;
use strict;
use Pod::Usage;
use Getopt::Long 2.25 qw(:config posix_default no_ignore_case);
use Net::Server::Multiplex;
use BerkeleyDB;
use Fcntl ':flock'; # import LOCK_* constants
use Sys::Hostname;
use POSIX qw(strftime);

use vars qw(@ISA);
@ISA = qw(Net::Server::Multiplex);

my $VERSION = "1.17rc4";
my $hostname = hostname;

sub read_clients_whitelists($)
{
    my ($self) = @_;

    my @whitelist_clients = ();
    my @whitelist_ips = ();
    for my $f (@{$self->{postgrey}{whitelist_clients_files}}) {
        if(open(CLIENTS, $f)) {
            while(<CLIENTS>) {
                s/^\s+//; s/\s+$//; next if $_ eq '' or /^#/;
                if(/^\/(\S+)\/$/) {
                    # regular expression
                    push @whitelist_clients, qr{$1}i;
                }
                elsif(/^\d{1,3}(?:\.\d{1,3}){0,3}$/) {
                    # IP address or part of it
                    push @whitelist_ips, qr{^$_};
                }
                # note: we had ^[^\s\/]+$ but it triggers a bug in perl 5.8.0
                elsif(/^\S+$/) {
                    push @whitelist_clients, qr{\Q$_\E$}i;
                }
                else {
                    warn "WARNING: $f line $.: doesn't look like a hostname\n";
                }
            }
        }
        else {
            warn "WARNING: can't open $f: $!\n" unless $f =~ /\.local$/;
            # do not warn about .local file: maybe the user just doesn't have one
        }
        close(CLIENTS);
    }
    $self->{postgrey}{whitelist_clients} = \@whitelist_clients;
    $self->{postgrey}{whitelist_ips}     = \@whitelist_ips;
}

sub read_recipients_whitelists($)
{
    my ($self) = @_;

    my @whitelist_recipients = ();
    for my $f (@{$self->{postgrey}{whitelist_recipients_files}}) {
        if(open(RECIPIENTS, $f)) {
            while(<RECIPIENTS>) {
                s/^\s+//; s/\s+$//; next if $_ eq '' or /^#/;
                my ($user, $domain) = split(/\@/, $_, 2);
                if(/^\/(\S+)\/$/) {
                    # regular expression
                    push @whitelist_recipients, qr{$1}i;
                }
                elsif(!/^\S+$/) {
                    warn "WARNING: $f line $.: doesn't look like an address\n";
                }
                # postfix access(5) syntax:
                elsif(defined $domain and $domain ne '') {
                    # user@domain (match also user+extension@domain)
                    push @whitelist_recipients, qr{^\Q$user\E(?:\+[^@]+)?\@\Q$domain\E$}i;
                }
                elsif(defined $domain) {
                    # user@
                    push @whitelist_recipients, qr{^\Q$user\E(?:\+[^@]+)?\@}i;
                }
                else {
                    # domain ($user is the domain)
                    push @whitelist_recipients, qr{\Q$user\E$}i;
                }
            }
        }
        else {
            warn "WARNING: can't open $f: $!\n" unless $f =~ /\.local$/;
            # do not warn about .local file: maybe the user just doesn't have one
        }
        close(RECIPIENTS);
    }
    $self->{postgrey}{whitelist_recipients} = \@whitelist_recipients;
}

sub do_sender_substitutions($$)
{
    my ($self, $addr) = @_;

    my ($user, $domain) = split(/@/, $addr, 2);
    defined $domain or return $addr;
    # strip extension, used sometimes for mailing-list VERP
    $user =~ s/\+.*//;
    # replace numbers in VERP addresses with '#' so that
    # we don't create a new key for each mail
    $user =~ s/\b\d+\b/#/g;
    return "$user\@$domain";
}

# split network and host part and return both
sub do_client_substitutions($$$)
{
    my ($self, $ip, $revdns) = @_;

    if($self->{postgrey}{lookup_by_host}) {
        return ($ip, undef);
    }

    return ($ip, undef) if $revdns eq 'unknown';
    my @ip=split(/\./, $ip);
    return ($ip, undef) unless defined $ip[3];
    # skip if it contains the last two IP numbers in the hostname
    # (we assume it is a pool of dialup addresses of a provider)
    return ($ip, undef) if $revdns =~ /$ip[2]/ and $revdns =~ /$ip[3]/;
    return (join('.', @ip[0..2], '0'), $ip[3]);
}

sub do_maintenance($$)
{
    my ($self, $now) = @_;
    my $db     = $self->{postgrey}{db};
    my $db_env = $self->{postgrey}{db_env};

    # remove old db logs

    $self->log(2, "cleaning up old logs...");
    $db_env->txn_checkpoint(0, 0) and
        warn "can't checkpoint !? $BerkeleyDB::Error";
    for my $l ($db_env->log_archive(DB_ARCH_ABS)) {
        $self->log(2, "rm $l");
        unlink $l or warn "can't remove db log $l: $!\n";
    }

    # remove old keys
    # this is very expensive:  We might refuse to speak to postfix for too
    # long, after which clients will start getting "450 Server configuration
    # problem" errors... do it only during the night and only if at least one
    # day has passed
    my $hour = (localtime($now))[2];
    if($hour > 1 and $hour < 7 and
        $now - $self->{postgrey}{last_maint_keys} >= 82800)
    {
        $self->log(2, "cleaning up old entries...");
        my $max_age = $self->{postgrey}{max_age};
        my $retry_window = $self->{postgrey}{retry_window};
        my ($nr_keys_before, $nr_keys_after) = (0,0);
        while (my ($key, $value) = each %$db) {
            $nr_keys_before++;
            my ($first, $last) = split(/,/,$value);
            if($now - $last > $max_age) {
                delete $db->{$key};
            }
            elsif($first == $last and $now - $last > $retry_window) {
                delete $db->{$key};
            }
            else {
                $nr_keys_after++;
            }
        }
        $self->log(2, "cleaning host/sender/recipient database finished. before: $nr_keys_before, after: $nr_keys_after");

        if($self->{postgrey}{awl_clients}) {
            # cleanup clients auto-whitelist database
            my $cawl_db  = $self->{postgrey}{db_cawl};
            ($nr_keys_before, $nr_keys_after) = (0, 0);
            $nr_keys_after=0;
            while (my ($key, $value) = each %$cawl_db) {
                my $cawl_last_seen = (split(/,/, $value))[1];
                $nr_keys_before++;
                if($now - $cawl_last_seen > $max_age) {
                    delete $cawl_db->{$key};
                }
                else {
                    $nr_keys_after++;
                }
            }
            $self->log(2, "cleaning clients database finished. before: $nr_keys_before, after: $nr_keys_after");
        }

        $self->{postgrey}{last_maint_keys}=$now;
    }
}

sub is_new_instance($$)
{
    my ($self, $inst) = @_;
    # we keep a list of the last 20 "instances", which identify unique messages
    # so that for example we only put one X-Greylist header per message.
    $self->{postgrey}{instances} = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
        unless defined $self->{postgrey}{instances};

    my $i = $self->{postgrey}{instances};
    return 0 if scalar grep { $_ eq $inst } @$i;
    
    # put new value into the array
    unshift @$i, $inst;
    pop @$i;

    return 1;
}

# main routine: based on attributes specified as argument, return policy decision
sub smtpd_access_policy($$)
{
    my ($self, $attr) = @_;
    my $db  = $self->{postgrey}{db};
    my $now = time();

    # whitelists
    for my $w (@{$self->{postgrey}{whitelist_clients}}) {
        return 'DUNNO' if $attr->{client_name} =~ $w;
    }
    for my $w (@{$self->{postgrey}{whitelist_ips}}) {
        return 'DUNNO' if $attr->{client_address} =~ $w;
    }
    for my $w (@{$self->{postgrey}{whitelist_recipients}}) {
        return 'DUNNO' if $attr->{recipient} =~ $w;
    }

    # lookup
    my $sender = $self->do_sender_substitutions($attr->{sender});
    my ($client_net, $client_host) =
        $self->do_client_substitutions($attr->{client_address}, $attr->{client_name});
    my $key    = lc "$client_net/$sender/$attr->{recipient}";
    my $val    = $db->{$key};

    my $first;
    my $last_was_successful=0;
    if(defined $val) {
        my $last;
        ($first, $last) = split(/,/,$val);
        # find out if the last time was unsuccessful, so that we can add a header
        # to say how much had to be waited
        if($last - $first >= $self->{postgrey}{delay}) {
            $last_was_successful=1;
        }
        # discard stored first-seen if it is the first retrial and
        # it is beyond the retry_window
        if($first == $last and $now-$first > $self->{postgrey}{retry_window}) {
            $first = $now;
        }
    }
    else {
        $first = $now;
    }

    # update (put as last element stripped host-part if it was stripped)
    if(defined $client_host) {
        $db->{$key}="$first,$now,$client_host";
    }
    else {
        $db->{$key}="$first,$now";
    }

    # do maintenance if one hour has passed since the last one
    if($now-$self->{postgrey}{last_maint} >= 3600) {
        $self->{postgrey}{last_maint} = $now;
        $self->do_maintenance($now);
    }

    $self->log(4, "request age ".($now - $first));
    my $diff = $self->{postgrey}{delay} - ($now - $first);

    # auto whitelist clients
    # algorithm:
    # - on successful entry in the greylist db of a triplet:
    #   - client not whitelisted yet? -> increase count, whitelist if count > 10 or so
    #   - client whitelisted already? -> update last-seen timestamp
    if($self->{postgrey}{awl_clients}) {
        my $cawl_db  = $self->{postgrey}{db_cawl};
        my $cawl_key = $attr->{client_address};
        my $cawl_val = $cawl_db->{$cawl_key};
        my ($cawl_count, $cawl_last);
        ($cawl_count, $cawl_last) = split(/,/,$cawl_val) if defined $cawl_val;
        
        # whitelist if count is enough
        if(defined $cawl_count and $cawl_count >= $self->{postgrey}{awl_clients})
        {
            if($now >= $cawl_last+3600) {
                $cawl_count++; # for statistics
                $cawl_db->{$cawl_key}=$cawl_count.','.$now;
            }
            return 'DUNNO';
        }

        # greylisting succeeded
        if($diff <= 0 and !$last_was_successful) {
            # enough time has passed (record only one attempt per hour)
            if(! defined $cawl_last or $now >= $cawl_last + 3600) {
                # host has a proper DNS record
                if($attr->{client_name} ne 'unknown') {
                    # ok, increase count
                    $cawl_count++;
                    $cawl_db->{$cawl_key}=$cawl_count.','.$now;
                    $self->log(4, "whitelisted: $attr->{client_name}")
                        if $cawl_count==$self->{postgrey}{awl_clients};
                }
            }
        }
    }

    # not enough waited? -> greylist
    if ($diff > 0 ) {
        my $msg = $self->{postgrey}{greylist_text};
        $msg =~ s/\%s/$diff/;
        return "$self->{postgrey}{greylist_action} $msg";
    }

    # X-Greylist header:
    if($last_was_successful) {
        # we don't add an header, because probably this message wasn't delayed
        # at all, since the previous one could pass through already
        return 'DUNNO';
    }
    else {
        if($self->is_new_instance($attr->{instance})) {
            # add X-Greylist header
            my $date = strftime("%a, %d %b %Y %T %Z", localtime);
            return 'PREPEND X-Greylist: delayed '.($now-$first).
                " seconds by postgrey-$VERSION at $hostname; $date";
        }
    }
}

sub main()
{
    # save arguments for Net:Server HUP restart
    my @ARGV_saved = @ARGV;

    # do not output any localized texts!
    $ENV{LC_ALL}='C';

    # parse options
    my %opt = ();
    GetOptions(\%opt, 'help|h', 'man', 'version', 'noaction|no-action|n',
        'verbose|v', 'daemonize|d', 'unix|u=s', 'inet|i=s', 'user=s', 'group=s',
        'dbdir=s', 'pidfile=s', 'delay=i', 'max-age=i',
        'lookup-by-subnet', 'lookup-by-host', 'auto-whitelist-clients:s', 
        'whitelist-clients=s@', 'whitelist-recipients=s@',
        'retry-window=s', 'greylist-action=s', 'greylist-text=s',
    ) or exit(1);
    # note: lookup-by-subnet can be given for compatibility, but it is default
    # so do not do nothing with it...
    # note: auto-whitelist-clients:s and not auto-whitelist-clients:n so that
    # we can differentiate between --auto-whitelist-clients=0 and
    # auto-whitelist-clients

    if($opt{help})     { pod2usage(1) }
    if($opt{man})      { pod2usage(-exitstatus => 0, -verbose => 2) }
    if($opt{version})  { print "postgrey $VERSION\n"; exit(0) }
    if($opt{noaction}) { die "ERROR: don't know how to \"no-action\".\n" }

    defined $opt{unix} or defined $opt{inet} or
        die "ERROR: --unix or --inet must be specified\n";

    # bind only localhost if no host is specified
    if(defined $opt{inet} and $opt{inet}=~/^\d+$/) {
        $opt{inet} = "localhost:$opt{inet}";
    }

    # retry window
    my $retry_window = 24*3600*2; # default: 2 days
    if(defined $opt{'retry-window'}) {
        if($opt{'retry-window'} =~ /^(\d+)h$/i) {
            $retry_window = $1 * 3600;
        }
        elsif($opt{'retry-window'} =~ /^\d+$/) {
            $retry_window = $opt{'retry-window'} * 24 * 3600;
        }
        else {
            die "ERROR: --retry-window must be either a number of days or a number\n",
                "       followed by 'h' for hours ('6h' for example).\n";
        }
    }

    # create Net::Server object and run it
    my $server = bless {
        server => {
            commandline      => [ $0, @ARGV_saved ],
            port             => [ $opt{inet} ? $opt{inet} : $opt{unix}."|unix" ],
            proto            => $opt{inet} ? 'tcp' : 'unix',
            user             => $opt{user} || 'postgrey',
            group            => $opt{group} || 'nogroup',
            dbdir            => $opt{dbdir} || '/var/spool/postfix/postgrey',
            setsid           => $opt{daemonize} ? 1 : undef,
            pid_file         => $opt{daemonize} ? $opt{pidfile} : undef,
            log_level        => $opt{verbose} ? 4 : 2,
            log_file         => $opt{daemonize} ? 'Sys::Syslog' : undef,
            syslog_logsock   => $^O eq 'solaris' ? 'inet' : 'unix',
            syslog_facility  => 'mail',
            syslog_ident     => 'postgrey',
        },
        postgrey => {
            delay            => $opt{delay}     || 300,
            dbdir            => $opt{dbdir}     || '/var/spool/postfix/postgrey',
            max_age          => $opt{'max-age'} || 35,
            last_maint       => time,
            last_maint_keys  => 0, # do it on the first night
            lookup_by_host   => $opt{'lookup-by-host'},
            awl_clients      => defined $opt{'auto-whitelist-clients'} ?
                ($opt{'auto-whitelist-clients'} ne '' ?
                    $opt{'auto-whitelist-clients'} : 5) : 5,
            retry_window     => $retry_window,
            greylist_action  => $opt{'greylist-action'} || 'DEFER_IF_PERMIT',
            greylist_text    => $opt{'greylist-text'} || 'Greylisted for %s seconds (see http://isg.ee.ethz.ch/tools/postgrey/help)',
            whitelist_clients_files    => $opt{'whitelist-clients'} ||
                [ '/etc/postfix/postgrey_whitelist_clients' ,
                  '/etc/postfix/postgrey_whitelist_clients.local' ],
            whitelist_recipients_files => $opt{'whitelist-recipients'} ||
                [ '/etc/postfix/postgrey_whitelist_recipients' ],
        },
    }, 'postgrey';

    # max_age is in days
    $server->{postgrey}{max_age}*=3600*24;

    # read whitelist
    $server->read_clients_whitelists();
    $server->read_recipients_whitelists();

    $0 = join(' ', @{$server->{server}{commandline}});
    $server->run;
}

##### Net::Server::Multiplex methods:

# reload whitelists on HUP
sub sig_hup {
    my $self = shift;
    $self->log(2, "HUP received: reloading whitelists...");
    $self->read_clients_whitelists();
    $self->read_recipients_whitelists();
}

sub pre_loop_hook()
{
    my ($self) = @_;

    # write files with mode 600
    umask 0077;

    # unix socket permissions should be 666
    if($self->{server}{proto} eq 'unix') {
        my $unix_path = $self->{server}{port}[0];
        $unix_path =~ s/\|unix$//;
        chmod 0666, $unix_path;
    }

    # ensure that only one instance of postgrey is running
    my $lock = "$self->{server}{dbdir}/postgrey.lock";
    open(LOCK, ">>$lock") or die "ERROR: can't open lock file: $lock\n";
    flock(LOCK, LOCK_EX|LOCK_NB) or die "ERROR: locked: $lock\n";

    # be sure to put in syslog any warnings / fatal errors
    if($self->{server}{log_file} eq 'Sys::Syslog') {
        $SIG{__WARN__} = sub { Sys::Syslog::syslog('warning', "warning: $_[0]") };
        $SIG{__DIE__}  = sub { Sys::Syslog::syslog('crit', "fatal: $_[0]"); die @_; };
    }

    # open database with transactions, logging and auto-commit to make it as
    # safe as possible. Note that locking is not required since only one
    # process is running
    $self->{postgrey}{db_env} = BerkeleyDB::Env->new(
        -Home     => $self->{server}{dbdir},
        -Flags    => DB_CREATE|DB_RECOVER|DB_INIT_TXN|DB_INIT_MPOOL|DB_INIT_LOG,
        -SetFlags => DB_AUTO_COMMIT|DB_TXN_NOSYNC,
    ) or die "ERROR: can't create DB environment: $!\n";

    tie(%{$self->{postgrey}{db}}, 'BerkeleyDB::Btree',
        -Filename => 'postgrey.db',
        -Flags    => DB_CREATE,
        -Env      => $self->{postgrey}{db_env}
    ) or die "ERROR: can't create database $self->{server}{dbdir}/postgrey.db: $!\n";

    if($self->{postgrey}{awl_clients}) {
        tie(%{$self->{postgrey}{db_cawl}}, 'BerkeleyDB::Btree',
            -Filename => 'postgrey_clients.db',
            -Flags    => DB_CREATE,
            -Env      => $self->{postgrey}{db_env}
        ) or die "ERROR: can't create database $self->{server}{dbdir}/postgrey_clients.db: $!\n";
    }
}

sub mux_input()
{
    my ($self, $mux, $fh, $in_ref) = @_;
    defined $self->{postgrey_attr} or $self->{postgrey_attr} = {};
    my $attr = $self->{postgrey_attr};

    # consume entire lines
    while ($$in_ref =~ s/^([^\r\n]*)\r?\n//) {
        next unless defined $1;
        my $in = $1;
        if($in =~ /([^=]+)=(.*)/) {
            # read attributes
            $attr->{substr($1, 0, 512)} = substr($2, 0, 512);
        }
        elsif($in eq '') {
            defined $attr->{request} or $attr->{request}='';
            if($attr->{request} ne 'smtpd_access_policy') {
                $self->{net_server}->log(2, "unrecognized request type: '$attr->{request}'");
            }
            else {
                # decide
                my $action = $self->{net_server}->smtpd_access_policy($attr);
                # debug
                if($self->{net_server}{server}{log_level}>=4) {
                    my $a = 'request: ';
                    $a .= join(' ', map {"$_=$attr->{$_}"} (sort keys %$attr));
                    $a .= " action=$action";
                    $self->{net_server}->log(4, $a);
                }
                # give answer
                print $fh "action=$action\n\n";
            }
            $self->{postgrey_attr} = {};
        }
        else {
             $self->{net_server}->log(2, "ignoring garbage: <".substr($in, 0, 100).">");
        }
    }
}

main;

__END__

=head1 NAME

postgrey - Postfix Greylisting Policy Server

=head1 SYNOPSIS

B<postgrey> [I<options>...]

 -h, --help              display this help and exit
     --version           output version information and exit
 -v, --verbose           increase verbosity level

 -u, --unix=PATH         listen on unix socket PATH
 -i, --inet=[HOST:]PORT  listen on PORT, localhost if HOST is not specified
 -d, --daemonize         run in the background
     --pidfile=PATH      put daemon pid into this file
     --user=USER         run as USER (default: postgrey)
     --group=GROUP       run as group GROUP (default: nogroup)
     --dbdir=PATH        put db files in PATH (default: /var/spool/postfix/postgrey)
     --delay=N           greylist for N seconds (default: 300)
     --max-age=N         delete entries older than N days since the last time
                         that they have been seen (default: 35)
     --retry-window=N    allow only N days for the first retrial (default: 2)
                         append 'h' if you want to specify it in hours
     --greylist-action=A if greylisted, return A to Postfix (default: DEFER_IF_PERMIT)
     --greylist-text=TXT response when a mail is greylisted
                         (default: Greylisted for %s seconds)
     --lookup-by-subnet  strip the last 8 bits from IP addresses (default)
     --lookup-by-host    do not strip the last 8 bits from IP addresses
     --whitelist-clients=FILE     default: /etc/postfix/postgrey_whitelist_clients
     --whitelist-recipients=FILE  default: /etc/postfix/postgrey_whitelist_recipients
     --auto-whitelist-clients=N   whitelist host after first successful delievery
                                  N is the minimal count of mails before a client is 
                                  whitelisted (turned on by default with value 5)
                                  specify N=0 to disable.

 Note that the --whitelist-x options can be specified multiple times,
 and that per default /etc/postfix/postgrey_whitelist_clients.local is
 also read, so that you can put there local entries.

=head1 DESCRIPTION

Postgrey is a Postfix policy server implementing greylisting.

When a request for delivery of a mail is received by Postfix via SMTP, the
triplet C<CLIENT_IP> / C<SENDER> / C<RECIPIENT> is built. If it is the first
time that this triplet is seen, or if the triplet was first seen less than
I<delay> seconds (300 is the default), then the mail gets rejected with a
temporary error. Hopefully spammers or viruses will not try again later, as it
is however required per RFC.

Note that you shouldn't use the --lookup-by-host option unless you know what
you are doing: there are a lot of mail servers that use a pool of addresses to
send emails, so that they can change IP every time they try again. That's why
without this option postgrey will strip the last byte of the IP address when
doing lookups in the database.

=head2 Installation

=over 4

=item *

Create a C<postgrey> user and the directory where to put the database I<dbdir>
(default: C</var/spool/postfix/postgrey>)

=item *

Write an init script to start postgrey at boot and start it. Like this for example:

 postgrey --inet=10023 -d

=item *

Put something like this in /etc/main.cf:

 smtpd_recipient_restrictions =
               ...
               reject_unauth_destination
               check_policy_service inet:127.0.0.1:10023

=item *

Install the provided postgrey_whitelist_clients and
postgrey_whitelist_recipients in /etc/postfix.

=item *

Put in /etc/postfix/postgrey_whitelist_recipients users that do not want
greylisting.

=back

=head2 Whitelists

Whitelists allow you to specify client addresses or recipient address, for
which no greylisting should be done. Per default postgrey will read the
following files:

 /etc/postfix/postgrey_whitelist_clients
 /etc/postfix/postgrey_whitelist_clients.local
 /etc/postfix/postgrey_whitelist_recipients

You can specify alternative paths with the --whitelist-x options.

Postgrey whitelists follow similar syntax rules as Postfix access tables.
The following can be specified for B<recipient addresses>:

=over 10

=item domain.addr

C<domain.addr> domain and subdomains.

=item name@

C<name@.*> and extended addresses C<name+blabla@.*>.

=item name@domain.addr

C<name@domain.addr> and extended addresses.

=item /regexp/

anything that matches C<regexp> (the full address is matched).

=back

The following can be specified for B<client addresses>:

=over 10

=item domain.addr

C<domain.addr> domain and subdomains.

=item IP1.IP2.IP3.IP4

IP address IP1.IP2.IP3.IP4. You can also leave off one number, in
which case only the first specified numbers will be checked.

=item /regexp/

anything that matches C<regexp> (the full address is matched).

=back

=head2 Auto-whitelisting clients

With the option --auto-whitelist-clients a client IP address will be
automatically whitelisted if the following conditions are met:

=over 4

=item *

At least 5 successfull attempts of delivering a mail (after greylisting was
done). That number can be changed by specifying a number after the
--auto-whitelist-clients argument. Only one attempt per hour counts.

=item *

The client was last seen before --max-age days (35 per default).

=back

=head2 Greylist Action

To set the action to be returned to postfix when a message fails
postgrey's tests and should be deferred, use the
--greylist-action=ACTION option.

By default, postgrey returns DEFER_IF_PERMIT, which causes postfix to
check the rest of the restrictions and defer the message only if it
would otherwise be accepted.  A delay action of 451 causes postfix to
always defer the message with an SMTP reply code of 451 (temp fail).

See the postfix manual page access(5) for a discussion of the actions
allowed.

=head2 SEE ALSO

See L<http://www.greylisting.org/> for a description of what
greylisting is and L<http://www.postfix.org/SMTPD_POLICY_README.html>
for a description of how Postfix policy servers work.

=head1 COPYRIGHT

Copyright (c) 2004 by ETH Zurich. All rights reserved.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

=head1 AUTHOR

S<David Schweikert E<lt>dws@ee.ethz.chE<gt>>

=head1 HISTORY

 2004-05-20 ds Initial Version

=cut

# Emacs Configuration
#
# Local Variables:
# mode: cperl
# eval: (cperl-set-style "PerlStyle")
# mode: flyspell
# mode: flyspell-prog
# End:
#
# vi: sw=4 et
